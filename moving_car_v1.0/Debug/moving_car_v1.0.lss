
moving_car_v1.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000054e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000005c2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00800060  00800060  000005c2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005c2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000005f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000140  00000000  00000000  00000630  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001340  00000000  00000000  00000770  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000093b  00000000  00000000  00001ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c86  00000000  00000000  000023eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000210  00000000  00000000  00003074  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000079d  00000000  00000000  00003284  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009fc  00000000  00000000  00003a21  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  0000441d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a4 36       	cpi	r26, 0x64	; 100
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 39 01 	call	0x272	; 0x272 <main>
  74:	0c 94 a5 02 	jmp	0x54a	; 0x54a <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <APP_init>:
static uint8_t u8_gs_stop  = 0;//u8_gs_stop flag


void APP_init(void)
{
	TMR0_init();  /** INITIALIZE TIMER 0 **/
  7c:	0e 94 3c 02 	call	0x478	; 0x478 <TMR0_init>
	
    //Interrupt initialization
    SREG  |= (1<<7);//enable global interrupt
  80:	8f b7       	in	r24, 0x3f	; 63
  82:	80 68       	ori	r24, 0x80	; 128
  84:	8f bf       	out	0x3f, r24	; 63
    MCUCR |= (1<<0) | (1<<1); //setting interrupt 0 sense control to rising edge
  86:	85 b7       	in	r24, 0x35	; 53
  88:	83 60       	ori	r24, 0x03	; 3
  8a:	85 bf       	out	0x35, r24	; 53
    MCUCR |= (1<<2) | (1<<3); //setting interrupt 1 sense control to rising edge
  8c:	85 b7       	in	r24, 0x35	; 53
  8e:	8c 60       	ori	r24, 0x0C	; 12
  90:	85 bf       	out	0x35, r24	; 53
    GICR  |= (1<<6) | (1<<7); //enable external interrupt 0 & External Interrupt 1
  92:	8b b7       	in	r24, 0x3b	; 59
  94:	80 6c       	ori	r24, 0xC0	; 192
  96:	8b bf       	out	0x3b, r24	; 59
    TIMSK |= (1<<6); //enable timer 2 interrupt
  98:	89 b7       	in	r24, 0x39	; 57
  9a:	80 64       	ori	r24, 0x40	; 64
  9c:	89 bf       	out	0x39, r24	; 57
	TIMER2_normalMode();//Set timer 2 to normal mode
  9e:	0e 94 9d 02 	call	0x53a	; 0x53a <TIMER2_normalMode>
	
	MOTOR_init(MOTOR1_ID);  /** INIALIZE MOTOR 1 **/
  a2:	80 e0       	ldi	r24, 0x00	; 0
  a4:	0e 94 6d 00 	call	0xda	; 0xda <MOTOR_init>
	
	MOTOR_init(MOTOR2_ID);  /** INIALIZE MOTOR 1 **/
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	0e 94 6d 00 	call	0xda	; 0xda <MOTOR_init>
	
	MOTOR_turnoff(MOTOR1_ID); /** MOTOR 1 IS OFF IN THE BEGINNING **/
  ae:	80 e0       	ldi	r24, 0x00	; 0
  b0:	0e 94 b5 00 	call	0x16a	; 0x16a <MOTOR_turnoff>
	
	MOTOR_turnoff(MOTOR2_ID); /** MOTOR 1 IS OFF IN THE BEGINNING **/
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	0e 94 b5 00 	call	0x16a	; 0x16a <MOTOR_turnoff>
	
	MOTOR_rotateclkdir(MOTOR1_ID); /** MOTOR 1 ROTATE CLOCKWISE **/
  ba:	80 e0       	ldi	r24, 0x00	; 0
  bc:	0e 94 96 00 	call	0x12c	; 0x12c <MOTOR_rotateclkdir>
	
	MOTOR_rotateclkdir(MOTOR2_ID); /** MOTOR 1 ROTATE CLOCKWISE **/
  c0:	81 e0       	ldi	r24, 0x01	; 1
  c2:	0e 94 96 00 	call	0x12c	; 0x12c <MOTOR_rotateclkdir>
  c6:	08 95       	ret

000000c8 <APP_start>:
// 	u16_l_ovf = TIMER2_getInitialValue(3000);
// 	TIMER2_perscalerMode(PRESCALER_MODE);
	
/*	while(u16_gs_currentCount<u16_l_ovf)*/
//	{
		MOTOR_applyspeed(MOTOR1_ID , speed_mode_2);
  c8:	61 e0       	ldi	r22, 0x01	; 1
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	0e 94 cf 00 	call	0x19e	; 0x19e <MOTOR_applyspeed>
		MOTOR_applyspeed(MOTOR2_ID , speed_mode_2);		
  d0:	61 e0       	ldi	r22, 0x01	; 1
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	0e 94 cf 00 	call	0x19e	; 0x19e <MOTOR_applyspeed>
  d8:	08 95       	ret

000000da <MOTOR_init>:
		break;
		
	}
	
	return en_a_motorrotatestatus ; /** RETURN THE FINAL STATUS **/
}
  da:	88 23       	and	r24, r24
  dc:	19 f0       	breq	.+6      	; 0xe4 <MOTOR_init+0xa>
  de:	81 30       	cpi	r24, 0x01	; 1
  e0:	91 f0       	breq	.+36     	; 0x106 <MOTOR_init+0x2c>
  e2:	22 c0       	rjmp	.+68     	; 0x128 <MOTOR_init+0x4e>
  e4:	41 e0       	ldi	r20, 0x01	; 1
  e6:	60 e0       	ldi	r22, 0x00	; 0
  e8:	80 e0       	ldi	r24, 0x00	; 0
  ea:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
  ee:	41 e0       	ldi	r20, 0x01	; 1
  f0:	61 e0       	ldi	r22, 0x01	; 1
  f2:	80 e0       	ldi	r24, 0x00	; 0
  f4:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
  f8:	41 e0       	ldi	r20, 0x01	; 1
  fa:	64 e0       	ldi	r22, 0x04	; 4
  fc:	80 e0       	ldi	r24, 0x00	; 0
  fe:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
 102:	80 e0       	ldi	r24, 0x00	; 0
 104:	08 95       	ret
 106:	41 e0       	ldi	r20, 0x01	; 1
 108:	62 e0       	ldi	r22, 0x02	; 2
 10a:	80 e0       	ldi	r24, 0x00	; 0
 10c:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
 110:	41 e0       	ldi	r20, 0x01	; 1
 112:	63 e0       	ldi	r22, 0x03	; 3
 114:	80 e0       	ldi	r24, 0x00	; 0
 116:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
 11a:	41 e0       	ldi	r20, 0x01	; 1
 11c:	65 e0       	ldi	r22, 0x05	; 5
 11e:	80 e0       	ldi	r24, 0x00	; 0
 120:	0e 94 3e 01 	call	0x27c	; 0x27c <DIO_setpindir>
 124:	80 e0       	ldi	r24, 0x00	; 0
 126:	08 95       	ret
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	08 95       	ret

0000012c <MOTOR_rotateclkdir>:
 12c:	88 23       	and	r24, r24
 12e:	19 f0       	breq	.+6      	; 0x136 <MOTOR_rotateclkdir+0xa>
 130:	81 30       	cpi	r24, 0x01	; 1
 132:	69 f0       	breq	.+26     	; 0x14e <MOTOR_rotateclkdir+0x22>
 134:	18 c0       	rjmp	.+48     	; 0x166 <MOTOR_rotateclkdir+0x3a>
 136:	41 e0       	ldi	r20, 0x01	; 1
 138:	60 e0       	ldi	r22, 0x00	; 0
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
 140:	40 e0       	ldi	r20, 0x00	; 0
 142:	61 e0       	ldi	r22, 0x01	; 1
 144:	80 e0       	ldi	r24, 0x00	; 0
 146:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	08 95       	ret
 14e:	41 e0       	ldi	r20, 0x01	; 1
 150:	62 e0       	ldi	r22, 0x02	; 2
 152:	80 e0       	ldi	r24, 0x00	; 0
 154:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
 158:	40 e0       	ldi	r20, 0x00	; 0
 15a:	63 e0       	ldi	r22, 0x03	; 3
 15c:	80 e0       	ldi	r24, 0x00	; 0
 15e:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
 162:	80 e0       	ldi	r24, 0x00	; 0
 164:	08 95       	ret
 166:	81 e0       	ldi	r24, 0x01	; 1
 168:	08 95       	ret

0000016a <MOTOR_turnoff>:
/*****************************************************************/
MOTOR_init_status MOTOR_turnoff(uint8_t u8_a_motorid)
{
	MOTOR_init_status en_a_motoroffstatus = VALID_MOTOR_INIT ; /** VARIABLE TO HOLD THE RETURN STATUS **/
	
	switch(u8_a_motorid)
 16a:	88 23       	and	r24, r24
 16c:	19 f0       	breq	.+6      	; 0x174 <MOTOR_turnoff+0xa>
 16e:	81 30       	cpi	r24, 0x01	; 1
 170:	41 f0       	breq	.+16     	; 0x182 <MOTOR_turnoff+0x18>
 172:	13 c0       	rjmp	.+38     	; 0x19a <MOTOR_turnoff+0x30>
	{
		case MOTOR1_ID : /** SET PINS OF MOTOR 1 **/
		
		DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_LOW); /** THE TWO PINS ARE HIGH **/
 174:	40 e0       	ldi	r20, 0x00	; 0
 176:	64 e0       	ldi	r22, 0x04	; 4
 178:	80 e0       	ldi	r24, 0x00	; 0
 17a:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
/** ARGUMENTS  : MOTOR ID                                       **/
/** RETURN     :  MOTOR INIT ERROR STATUS                       **/
/*****************************************************************/
MOTOR_init_status MOTOR_turnoff(uint8_t u8_a_motorid)
{
	MOTOR_init_status en_a_motoroffstatus = VALID_MOTOR_INIT ; /** VARIABLE TO HOLD THE RETURN STATUS **/
 17e:	80 e0       	ldi	r24, 0x00	; 0
	{
		case MOTOR1_ID : /** SET PINS OF MOTOR 1 **/
		
		DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_LOW); /** THE TWO PINS ARE HIGH **/
		//DIO_setpinvalue(MOTOR2_PORT , MOTOR2_ENABLE_PIN , DIO_PIN_LOW);
		break;
 180:	08 95       	ret
		
		case MOTOR2_ID:  /** SET PINS OF MOTOR 2 **/
		
		DIO_setpinvalue(MOTOR2_PORT , MOTOR2_PIN1 , DIO_PIN_HIGH); /** THE TWO PINS ARE HIGH **/
 182:	41 e0       	ldi	r20, 0x01	; 1
 184:	62 e0       	ldi	r22, 0x02	; 2
 186:	80 e0       	ldi	r24, 0x00	; 0
 188:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
		DIO_setpinvalue(MOTOR2_PORT , MOTOR2_PIN2 , DIO_PIN_HIGH);
 18c:	41 e0       	ldi	r20, 0x01	; 1
 18e:	63 e0       	ldi	r22, 0x03	; 3
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
/** ARGUMENTS  : MOTOR ID                                       **/
/** RETURN     :  MOTOR INIT ERROR STATUS                       **/
/*****************************************************************/
MOTOR_init_status MOTOR_turnoff(uint8_t u8_a_motorid)
{
	MOTOR_init_status en_a_motoroffstatus = VALID_MOTOR_INIT ; /** VARIABLE TO HOLD THE RETURN STATUS **/
 196:	80 e0       	ldi	r24, 0x00	; 0
		
		case MOTOR2_ID:  /** SET PINS OF MOTOR 2 **/
		
		DIO_setpinvalue(MOTOR2_PORT , MOTOR2_PIN1 , DIO_PIN_HIGH); /** THE TWO PINS ARE HIGH **/
		DIO_setpinvalue(MOTOR2_PORT , MOTOR2_PIN2 , DIO_PIN_HIGH);
		break;
 198:	08 95       	ret
		
		
		default:
		/** RETURN ERROR **/
		en_a_motoroffstatus = NOTVALID_MOTOR_INIT ; /** AN ERROR IN INITIALIZE MOTOR **/
 19a:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
	}
	
	return en_a_motoroffstatus ; /** RETURN THE FINAL STATUS **/
}
 19c:	08 95       	ret

0000019e <MOTOR_applyspeed>:
/*****************************************************************/
MOTOR_init_status MOTOR_applyspeed(uint8_t u8_a_motorid  , uint8_t u8_a_speed)
{
	MOTOR_init_status en_a_motoroffstatus = VALID_MOTOR_INIT ; /** VARIABLE TO HOLD THE RETURN STATUS **/
	
	switch (u8_a_motorid)
 19e:	88 23       	and	r24, r24
 1a0:	19 f0       	breq	.+6      	; 0x1a8 <MOTOR_applyspeed+0xa>
 1a2:	81 30       	cpi	r24, 0x01	; 1
 1a4:	a1 f1       	breq	.+104    	; 0x20e <MOTOR_applyspeed+0x70>
 1a6:	08 95       	ret
		/** tick time = (1024) / (16MHZ)   = 64 Micro second                                 **/
		/** IF WE NEED 50% DUTY CYCLE THEN 1 TICK_TIME ON THEN  1 TICK_TIME OFF              **/
		/** IF WE NEED 70% DUTY CYCLE THEN 7 TICK_TIMES ON THEN 3 TICK_TIMES OFF             **/
		/** IF WE NEED 90% DUTY CYCLE THEN 9 TICK_TIMES ON THEN 1 TICK_TIMES OFF             **/
		/**************************************************************************************/
		if (u8_a_speed == speed_mode_1) /** APPLY SPEED MODE 1 ON MOTOR 1 50 % DUTY CYCLE **/
 1a8:	61 11       	cpse	r22, r1
 1aa:	17 c0       	rjmp	.+46     	; 0x1da <MOTOR_applyspeed+0x3c>
		{
			DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_HIGH);
 1ac:	41 e0       	ldi	r20, 0x01	; 1
 1ae:	64 e0       	ldi	r22, 0x04	; 4
 1b0:	80 e0       	ldi	r24, 0x00	; 0
 1b2:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(64);
 1b6:	60 e4       	ldi	r22, 0x40	; 64
 1b8:	70 e0       	ldi	r23, 0x00	; 0
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
			
			DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_LOW);
 1c2:	40 e0       	ldi	r20, 0x00	; 0
 1c4:	64 e0       	ldi	r22, 0x04	; 4
 1c6:	80 e0       	ldi	r24, 0x00	; 0
 1c8:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(64);
 1cc:	60 e4       	ldi	r22, 0x40	; 64
 1ce:	70 e0       	ldi	r23, 0x00	; 0
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	90 e0       	ldi	r25, 0x00	; 0
 1d4:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
 1d8:	08 95       	ret
			
		}
		
		else if (u8_a_speed == speed_mode_2) /** APPLY SPEED MODE 2 ON MOTOR 1 30 % DUTY CYCLE **/
 1da:	61 30       	cpi	r22, 0x01	; 1
 1dc:	09 f0       	breq	.+2      	; 0x1e0 <MOTOR_applyspeed+0x42>
 1de:	48 c0       	rjmp	.+144    	; 0x270 <MOTOR_applyspeed+0xd2>
		{
			DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_HIGH);
 1e0:	41 e0       	ldi	r20, 0x01	; 1
 1e2:	64 e0       	ldi	r22, 0x04	; 4
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(192);
 1ea:	60 ec       	ldi	r22, 0xC0	; 192
 1ec:	70 e0       	ldi	r23, 0x00	; 0
 1ee:	80 e0       	ldi	r24, 0x00	; 0
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
			
			DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_LOW);
 1f6:	40 e0       	ldi	r20, 0x00	; 0
 1f8:	64 e0       	ldi	r22, 0x04	; 4
 1fa:	80 e0       	ldi	r24, 0x00	; 0
 1fc:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(448);
 200:	60 ec       	ldi	r22, 0xC0	; 192
 202:	71 e0       	ldi	r23, 0x01	; 1
 204:	80 e0       	ldi	r24, 0x00	; 0
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
 20c:	08 95       	ret
		}
		break;
		
		case MOTOR2_ID:
		
		if (u8_a_speed == speed_mode_1) /** APPLY SPEED MODE 1 ON MOTOR 2 50 % DUTY CYCLE **/
 20e:	61 11       	cpse	r22, r1
 210:	17 c0       	rjmp	.+46     	; 0x240 <MOTOR_applyspeed+0xa2>
		{
			DIO_setpinvalue(MOTOR2_PORT , MOTOR2_ENABLE_PIN , DIO_PIN_HIGH);
 212:	41 e0       	ldi	r20, 0x01	; 1
 214:	65 e0       	ldi	r22, 0x05	; 5
 216:	80 e0       	ldi	r24, 0x00	; 0
 218:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(64);
 21c:	60 e4       	ldi	r22, 0x40	; 64
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
			
			DIO_setpinvalue(MOTOR1_PORT , MOTOR1_ENABLE_PIN , DIO_PIN_LOW);
 228:	40 e0       	ldi	r20, 0x00	; 0
 22a:	64 e0       	ldi	r22, 0x04	; 4
 22c:	80 e0       	ldi	r24, 0x00	; 0
 22e:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(64);
 232:	60 e4       	ldi	r22, 0x40	; 64
 234:	70 e0       	ldi	r23, 0x00	; 0
 236:	80 e0       	ldi	r24, 0x00	; 0
 238:	90 e0       	ldi	r25, 0x00	; 0
 23a:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
 23e:	08 95       	ret
			
		}
		
		else if (u8_a_speed == speed_mode_2) /** APPLY SPEED MODE 2 ON MOTOR 2 30 % DUTY CYCLE **/
 240:	61 30       	cpi	r22, 0x01	; 1
 242:	b1 f4       	brne	.+44     	; 0x270 <MOTOR_applyspeed+0xd2>
		{
			DIO_setpinvalue(MOTOR2_PORT , MOTOR2_ENABLE_PIN , DIO_PIN_HIGH);
 244:	41 e0       	ldi	r20, 0x01	; 1
 246:	65 e0       	ldi	r22, 0x05	; 5
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(192);
 24e:	60 ec       	ldi	r22, 0xC0	; 192
 250:	70 e0       	ldi	r23, 0x00	; 0
 252:	80 e0       	ldi	r24, 0x00	; 0
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
			
			DIO_setpinvalue(MOTOR2_PORT , MOTOR2_ENABLE_PIN , DIO_PIN_LOW);
 25a:	40 e0       	ldi	r20, 0x00	; 0
 25c:	65 e0       	ldi	r22, 0x05	; 5
 25e:	80 e0       	ldi	r24, 0x00	; 0
 260:	0e 94 bd 01 	call	0x37a	; 0x37a <DIO_setpinvalue>
			TMR0_delaymicos(448);
 264:	60 ec       	ldi	r22, 0xC0	; 192
 266:	71 e0       	ldi	r23, 0x01	; 1
 268:	80 e0       	ldi	r24, 0x00	; 0
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	0e 94 69 02 	call	0x4d2	; 0x4d2 <TMR0_delaymicos>
		}
		
	}
 270:	08 95       	ret

00000272 <main>:

#include "APP/APP.h"

int main(void)
{
	APP_init();
 272:	0e 94 3e 00 	call	0x7c	; 0x7c <APP_init>
	
    /* Replace with your application code */
    while (1) 
    {
		APP_start();
 276:	0e 94 64 00 	call	0xc8	; 0xc8 <APP_start>
 27a:	fd cf       	rjmp	.-6      	; 0x276 <main+0x4>

0000027c <DIO_setpindir>:
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
	
	switch(u8_a_pindir) /** SWITCH CASE ON THE DIRECTION VALUE **/
 27c:	44 23       	and	r20, r20
 27e:	19 f0       	breq	.+6      	; 0x286 <DIO_setpindir+0xa>
 280:	41 30       	cpi	r20, 0x01	; 1
 282:	e9 f1       	breq	.+122    	; 0x2fe <DIO_setpindir+0x82>
 284:	74 c0       	rjmp	.+232    	; 0x36e <DIO_setpindir+0xf2>
	{
		case DIO_PIN_INPUT:  /* INPUT CASE  */
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
 286:	81 30       	cpi	r24, 0x01	; 1
 288:	99 f0       	breq	.+38     	; 0x2b0 <DIO_setpindir+0x34>
 28a:	28 f0       	brcs	.+10     	; 0x296 <DIO_setpindir+0x1a>
 28c:	82 30       	cpi	r24, 0x02	; 2
 28e:	e9 f0       	breq	.+58     	; 0x2ca <DIO_setpindir+0x4e>
 290:	83 30       	cpi	r24, 0x03	; 3
 292:	41 f1       	breq	.+80     	; 0x2e4 <DIO_setpindir+0x68>
 294:	6e c0       	rjmp	.+220    	; 0x372 <DIO_setpindir+0xf6>
		{
			case DIO_PORTA:
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
 296:	2a b3       	in	r18, 0x1a	; 26
 298:	81 e0       	ldi	r24, 0x01	; 1
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	02 c0       	rjmp	.+4      	; 0x2a2 <DIO_setpindir+0x26>
 29e:	88 0f       	add	r24, r24
 2a0:	99 1f       	adc	r25, r25
 2a2:	6a 95       	dec	r22
 2a4:	e2 f7       	brpl	.-8      	; 0x29e <DIO_setpindir+0x22>
 2a6:	80 95       	com	r24
 2a8:	82 23       	and	r24, r18
 2aa:	8a bb       	out	0x1a, r24	; 26
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 2ac:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
		{
			case DIO_PORTA:
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
			break;
 2ae:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
 2b0:	27 b3       	in	r18, 0x17	; 23
 2b2:	81 e0       	ldi	r24, 0x01	; 1
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	02 c0       	rjmp	.+4      	; 0x2bc <DIO_setpindir+0x40>
 2b8:	88 0f       	add	r24, r24
 2ba:	99 1f       	adc	r25, r25
 2bc:	6a 95       	dec	r22
 2be:	e2 f7       	brpl	.-8      	; 0x2b8 <DIO_setpindir+0x3c>
 2c0:	80 95       	com	r24
 2c2:	82 23       	and	r24, r18
 2c4:	87 bb       	out	0x17, r24	; 23
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 2c6:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
			break;
			
			case DIO_PORTB:
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
			break;
 2c8:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
 2ca:	24 b3       	in	r18, 0x14	; 20
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	02 c0       	rjmp	.+4      	; 0x2d6 <DIO_setpindir+0x5a>
 2d2:	88 0f       	add	r24, r24
 2d4:	99 1f       	adc	r25, r25
 2d6:	6a 95       	dec	r22
 2d8:	e2 f7       	brpl	.-8      	; 0x2d2 <DIO_setpindir+0x56>
 2da:	80 95       	com	r24
 2dc:	82 23       	and	r24, r18
 2de:	84 bb       	out	0x14, r24	; 20
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 2e0:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
			break;
			
			case DIO_PORTC:
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
			break;
 2e2:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
 2e4:	21 b3       	in	r18, 0x11	; 17
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	02 c0       	rjmp	.+4      	; 0x2f0 <DIO_setpindir+0x74>
 2ec:	88 0f       	add	r24, r24
 2ee:	99 1f       	adc	r25, r25
 2f0:	6a 95       	dec	r22
 2f2:	e2 f7       	brpl	.-8      	; 0x2ec <DIO_setpindir+0x70>
 2f4:	80 95       	com	r24
 2f6:	82 23       	and	r24, r18
 2f8:	81 bb       	out	0x11, r24	; 17
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 2fa:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
			break;
			
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
			break;
 2fc:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_OUTPUT:  /* OUTPUT CASE  */
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
 2fe:	81 30       	cpi	r24, 0x01	; 1
 300:	91 f0       	breq	.+36     	; 0x326 <DIO_setpindir+0xaa>
 302:	28 f0       	brcs	.+10     	; 0x30e <DIO_setpindir+0x92>
 304:	82 30       	cpi	r24, 0x02	; 2
 306:	d9 f0       	breq	.+54     	; 0x33e <DIO_setpindir+0xc2>
 308:	83 30       	cpi	r24, 0x03	; 3
 30a:	29 f1       	breq	.+74     	; 0x356 <DIO_setpindir+0xda>
 30c:	34 c0       	rjmp	.+104    	; 0x376 <DIO_setpindir+0xfa>
		{
			case DIO_PORTA:
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 30e:	2a b3       	in	r18, 0x1a	; 26
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	02 c0       	rjmp	.+4      	; 0x31a <DIO_setpindir+0x9e>
 316:	88 0f       	add	r24, r24
 318:	99 1f       	adc	r25, r25
 31a:	6a 95       	dec	r22
 31c:	e2 f7       	brpl	.-8      	; 0x316 <DIO_setpindir+0x9a>
 31e:	82 2b       	or	r24, r18
 320:	8a bb       	out	0x1a, r24	; 26
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 322:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
		{
			case DIO_PORTA:
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 324:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 326:	27 b3       	in	r18, 0x17	; 23
 328:	81 e0       	ldi	r24, 0x01	; 1
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	02 c0       	rjmp	.+4      	; 0x332 <DIO_setpindir+0xb6>
 32e:	88 0f       	add	r24, r24
 330:	99 1f       	adc	r25, r25
 332:	6a 95       	dec	r22
 334:	e2 f7       	brpl	.-8      	; 0x32e <DIO_setpindir+0xb2>
 336:	82 2b       	or	r24, r18
 338:	87 bb       	out	0x17, r24	; 23
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 33a:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTB:
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 33c:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 33e:	24 b3       	in	r18, 0x14	; 20
 340:	81 e0       	ldi	r24, 0x01	; 1
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	02 c0       	rjmp	.+4      	; 0x34a <DIO_setpindir+0xce>
 346:	88 0f       	add	r24, r24
 348:	99 1f       	adc	r25, r25
 34a:	6a 95       	dec	r22
 34c:	e2 f7       	brpl	.-8      	; 0x346 <DIO_setpindir+0xca>
 34e:	82 2b       	or	r24, r18
 350:	84 bb       	out	0x14, r24	; 20
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 352:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTC:
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 354:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 356:	21 b3       	in	r18, 0x11	; 17
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	02 c0       	rjmp	.+4      	; 0x362 <DIO_setpindir+0xe6>
 35e:	88 0f       	add	r24, r24
 360:	99 1f       	adc	r25, r25
 362:	6a 95       	dec	r22
 364:	e2 f7       	brpl	.-8      	; 0x35e <DIO_setpindir+0xe2>
 366:	82 2b       	or	r24, r18
 368:	81 bb       	out	0x11, r24	; 17
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 36a:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 36c:	08 95       	ret
		} 
		break;
		 
		 
		default:  /** DIRECTION ISN'T INPUT OR OUTPUT */
		en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 36e:	81 e0       	ldi	r24, 0x01	; 1
 370:	08 95       	ret
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
			break;
			
			default: /** DO NOTHING **/
			en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 372:	81 e0       	ldi	r24, 0x01	; 1
 374:	08 95       	ret
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			default:  /** DO NOTHING **/
			en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 376:	81 e0       	ldi	r24, 0x01	; 1
		en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
		break ; 
	} 
	
	return en_a_dirstate ; /** RETURN THE STATE OF FUNCTION **/
}
 378:	08 95       	ret

0000037a <DIO_setpinvalue>:
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
	
	switch(u8_a_pinval)
 37a:	44 23       	and	r20, r20
 37c:	19 f0       	breq	.+6      	; 0x384 <DIO_setpinvalue+0xa>
 37e:	41 30       	cpi	r20, 0x01	; 1
 380:	e9 f1       	breq	.+122    	; 0x3fc <DIO_setpinvalue+0x82>
 382:	74 c0       	rjmp	.+232    	; 0x46c <__EEPROM_REGION_LENGTH__+0x6c>
	{
		case DIO_PIN_LOW:  /** IN CASE PIN VALUE IS LOW */
		
		switch(u8_a_portid)  /** SWITCH CASE ON THE PORT ID */ 
 384:	81 30       	cpi	r24, 0x01	; 1
 386:	99 f0       	breq	.+38     	; 0x3ae <DIO_setpinvalue+0x34>
 388:	28 f0       	brcs	.+10     	; 0x394 <DIO_setpinvalue+0x1a>
 38a:	82 30       	cpi	r24, 0x02	; 2
 38c:	e9 f0       	breq	.+58     	; 0x3c8 <DIO_setpinvalue+0x4e>
 38e:	83 30       	cpi	r24, 0x03	; 3
 390:	41 f1       	breq	.+80     	; 0x3e2 <DIO_setpinvalue+0x68>
 392:	6e c0       	rjmp	.+220    	; 0x470 <__EEPROM_REGION_LENGTH__+0x70>
		{
			case DIO_PORTA:
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 394:	2b b3       	in	r18, 0x1b	; 27
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	02 c0       	rjmp	.+4      	; 0x3a0 <DIO_setpinvalue+0x26>
 39c:	88 0f       	add	r24, r24
 39e:	99 1f       	adc	r25, r25
 3a0:	6a 95       	dec	r22
 3a2:	e2 f7       	brpl	.-8      	; 0x39c <DIO_setpinvalue+0x22>
 3a4:	80 95       	com	r24
 3a6:	82 23       	and	r24, r18
 3a8:	8b bb       	out	0x1b, r24	; 27
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 3aa:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid)  /** SWITCH CASE ON THE PORT ID */ 
		{
			case DIO_PORTA:
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 3ac:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 3ae:	28 b3       	in	r18, 0x18	; 24
 3b0:	81 e0       	ldi	r24, 0x01	; 1
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	02 c0       	rjmp	.+4      	; 0x3ba <DIO_setpinvalue+0x40>
 3b6:	88 0f       	add	r24, r24
 3b8:	99 1f       	adc	r25, r25
 3ba:	6a 95       	dec	r22
 3bc:	e2 f7       	brpl	.-8      	; 0x3b6 <DIO_setpinvalue+0x3c>
 3be:	80 95       	com	r24
 3c0:	82 23       	and	r24, r18
 3c2:	88 bb       	out	0x18, r24	; 24
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 3c4:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTB:
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 3c6:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 3c8:	25 b3       	in	r18, 0x15	; 21
 3ca:	81 e0       	ldi	r24, 0x01	; 1
 3cc:	90 e0       	ldi	r25, 0x00	; 0
 3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <DIO_setpinvalue+0x5a>
 3d0:	88 0f       	add	r24, r24
 3d2:	99 1f       	adc	r25, r25
 3d4:	6a 95       	dec	r22
 3d6:	e2 f7       	brpl	.-8      	; 0x3d0 <DIO_setpinvalue+0x56>
 3d8:	80 95       	com	r24
 3da:	82 23       	and	r24, r18
 3dc:	85 bb       	out	0x15, r24	; 21
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 3de:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTC:
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 3e0:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 3e2:	22 b3       	in	r18, 0x12	; 18
 3e4:	81 e0       	ldi	r24, 0x01	; 1
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	02 c0       	rjmp	.+4      	; 0x3ee <DIO_setpinvalue+0x74>
 3ea:	88 0f       	add	r24, r24
 3ec:	99 1f       	adc	r25, r25
 3ee:	6a 95       	dec	r22
 3f0:	e2 f7       	brpl	.-8      	; 0x3ea <DIO_setpinvalue+0x70>
 3f2:	80 95       	com	r24
 3f4:	82 23       	and	r24, r18
 3f6:	82 bb       	out	0x12, r24	; 18
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 3f8:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 3fa:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_HIGH:
		
		switch(u8_a_portid)
 3fc:	81 30       	cpi	r24, 0x01	; 1
 3fe:	91 f0       	breq	.+36     	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 400:	28 f0       	brcs	.+10     	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
 402:	82 30       	cpi	r24, 0x02	; 2
 404:	d9 f0       	breq	.+54     	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
 406:	83 30       	cpi	r24, 0x03	; 3
 408:	29 f1       	breq	.+74     	; 0x454 <__EEPROM_REGION_LENGTH__+0x54>
 40a:	34 c0       	rjmp	.+104    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
		{
			case DIO_PORTA:
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 40c:	2b b3       	in	r18, 0x1b	; 27
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	02 c0       	rjmp	.+4      	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
 414:	88 0f       	add	r24, r24
 416:	99 1f       	adc	r25, r25
 418:	6a 95       	dec	r22
 41a:	e2 f7       	brpl	.-8      	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
 41c:	82 2b       	or	r24, r18
 41e:	8b bb       	out	0x1b, r24	; 27
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 420:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid)
		{
			case DIO_PORTA:
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 422:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 424:	28 b3       	in	r18, 0x18	; 24
 426:	81 e0       	ldi	r24, 0x01	; 1
 428:	90 e0       	ldi	r25, 0x00	; 0
 42a:	02 c0       	rjmp	.+4      	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
 42c:	88 0f       	add	r24, r24
 42e:	99 1f       	adc	r25, r25
 430:	6a 95       	dec	r22
 432:	e2 f7       	brpl	.-8      	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
 434:	82 2b       	or	r24, r18
 436:	88 bb       	out	0x18, r24	; 24
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 438:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTB:
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 43a:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 43c:	25 b3       	in	r18, 0x15	; 21
 43e:	81 e0       	ldi	r24, 0x01	; 1
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	02 c0       	rjmp	.+4      	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
 444:	88 0f       	add	r24, r24
 446:	99 1f       	adc	r25, r25
 448:	6a 95       	dec	r22
 44a:	e2 f7       	brpl	.-8      	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
 44c:	82 2b       	or	r24, r18
 44e:	85 bb       	out	0x15, r24	; 21
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 450:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTC:
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 452:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 454:	22 b3       	in	r18, 0x12	; 18
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	90 e0       	ldi	r25, 0x00	; 0
 45a:	02 c0       	rjmp	.+4      	; 0x460 <__EEPROM_REGION_LENGTH__+0x60>
 45c:	88 0f       	add	r24, r24
 45e:	99 1f       	adc	r25, r25
 460:	6a 95       	dec	r22
 462:	e2 f7       	brpl	.-8      	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
 464:	82 2b       	or	r24, r18
 466:	82 bb       	out	0x12, r24	; 18
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 468:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 46a:	08 95       	ret
			break;
		} 
		break;
		
		default :
		en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 46c:	81 e0       	ldi	r24, 0x01	; 1
 46e:	08 95       	ret
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			default:
			en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	08 95       	ret
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			default:
			en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 474:	81 e0       	ldi	r24, 0x01	; 1
		en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
		break ;
	} 
	
	return en_a_valstate ; /** RETURN THE FINAL STATE OF THE FUNCTION */
}
 476:	08 95       	ret

00000478 <TMR0_init>:
	u32_gs_tmr0nuofovs = 0 ; /** REINTIALIZE THE OVERFLOWS COUNTER TO 0 AGAIN **/

	TMR0_stop();   /** STOP TMR0 TOSTART FROM 0 WHEN IT CALLED AGAIN **/
	
	return en_a_delaystatus ; /** RETURN THE STATUS **/
}
 478:	83 b7       	in	r24, 0x33	; 51
 47a:	8f 77       	andi	r24, 0x7F	; 127
 47c:	83 bf       	out	0x33, r24	; 51
 47e:	83 b7       	in	r24, 0x33	; 51
 480:	8f 7b       	andi	r24, 0xBF	; 191
 482:	83 bf       	out	0x33, r24	; 51
 484:	83 b7       	in	r24, 0x33	; 51
 486:	87 7f       	andi	r24, 0xF7	; 247
 488:	83 bf       	out	0x33, r24	; 51
 48a:	83 b7       	in	r24, 0x33	; 51
 48c:	8f 7e       	andi	r24, 0xEF	; 239
 48e:	83 bf       	out	0x33, r24	; 51
 490:	83 b7       	in	r24, 0x33	; 51
 492:	8f 7d       	andi	r24, 0xDF	; 223
 494:	83 bf       	out	0x33, r24	; 51
 496:	8f b7       	in	r24, 0x3f	; 63
 498:	80 68       	ori	r24, 0x80	; 128
 49a:	8f bf       	out	0x3f, r24	; 63
 49c:	89 b7       	in	r24, 0x39	; 57
 49e:	81 60       	ori	r24, 0x01	; 1
 4a0:	89 bf       	out	0x39, r24	; 57
 4a2:	80 e0       	ldi	r24, 0x00	; 0
 4a4:	08 95       	ret

000004a6 <TMR0_start>:
 4a6:	83 b7       	in	r24, 0x33	; 51
 4a8:	81 60       	ori	r24, 0x01	; 1
 4aa:	83 bf       	out	0x33, r24	; 51
 4ac:	83 b7       	in	r24, 0x33	; 51
 4ae:	8d 7f       	andi	r24, 0xFD	; 253
 4b0:	83 bf       	out	0x33, r24	; 51
 4b2:	83 b7       	in	r24, 0x33	; 51
 4b4:	8b 7f       	andi	r24, 0xFB	; 251
 4b6:	83 bf       	out	0x33, r24	; 51
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	08 95       	ret

000004bc <TMR0_stop>:
 4bc:	83 b7       	in	r24, 0x33	; 51
 4be:	8e 7f       	andi	r24, 0xFE	; 254
 4c0:	83 bf       	out	0x33, r24	; 51
 4c2:	83 b7       	in	r24, 0x33	; 51
 4c4:	8d 7f       	andi	r24, 0xFD	; 253
 4c6:	83 bf       	out	0x33, r24	; 51
 4c8:	83 b7       	in	r24, 0x33	; 51
 4ca:	8b 7f       	andi	r24, 0xFB	; 251
 4cc:	83 bf       	out	0x33, r24	; 51
 4ce:	80 e0       	ldi	r24, 0x00	; 0
 4d0:	08 95       	ret

000004d2 <TMR0_delaymicos>:
	
	en_a_delaystatus = VALID_DELAY ; /** VALID DELAY CONFIGURATIN **/
	
	#elif TIMER0_PRESCALER_VAL == NO_PRESCALER
	
	u32_gs_tmr0nuofovs = (u32_a_delaymicros / 16);   /** CALCULATING NUMBER OF OVERFLOWS ( DESIRED DELAY / TIME OF OVER FLOW ) **/
 4d2:	dc 01       	movw	r26, r24
 4d4:	cb 01       	movw	r24, r22
 4d6:	68 94       	set
 4d8:	13 f8       	bld	r1, 3
 4da:	b6 95       	lsr	r27
 4dc:	a7 95       	ror	r26
 4de:	97 95       	ror	r25
 4e0:	87 95       	ror	r24
 4e2:	16 94       	lsr	r1
 4e4:	d1 f7       	brne	.-12     	; 0x4da <TMR0_delaymicos+0x8>
 4e6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 4ea:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 4ee:	a0 93 62 00 	sts	0x0062, r26	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
 4f2:	b0 93 63 00 	sts	0x0063, r27	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
	
	TCNT0 = 0 ;   /** SET THE INITIAL VALUE IN TCNT0 REGISTER **/
 4f6:	12 be       	out	0x32, r1	; 50
	
	en_a_delaystatus = VALID_DELAY ; /** VALID DELAY CONFIGURATIN **/
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
 4f8:	0e 94 53 02 	call	0x4a6	; 0x4a6 <TMR0_start>
/** ARGUMENTS  : TAKES DELAY IN ms                                             */
/** RETURNS    : TMR0_delay                                                    */
/*******************************************************************************/
TMR0_delay_error TMR0_delaymicos(uint32_t u32_a_delaymicros)
{
	uint32_t u32_a_overflowcounter = 0 ;
 4fc:	40 e0       	ldi	r20, 0x00	; 0
 4fe:	50 e0       	ldi	r21, 0x00	; 0
 500:	ba 01       	movw	r22, r20
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
	
	while ( u32_a_overflowcounter < u32_gs_tmr0nuofovs ) /** STUCK IN THIS LOOP UNTILL THIS CONDITION IS FALSE **/
 502:	0a c0       	rjmp	.+20     	; 0x518 <TMR0_delaymicos+0x46>
	{
		while((TIFR & (1 << 0)) == 0); /** DO NOTHING UNTILL THIS FLAG RAISED (OVERFLOW HAPPENED) **/
 504:	08 b6       	in	r0, 0x38	; 56
 506:	00 fe       	sbrs	r0, 0
 508:	fd cf       	rjmp	.-6      	; 0x504 <TMR0_delaymicos+0x32>
		
		set_bit(TIFR , 0);        /** CLEAR THE FLAG BY SOFTWARE **/
 50a:	88 b7       	in	r24, 0x38	; 56
 50c:	81 60       	ori	r24, 0x01	; 1
 50e:	88 bf       	out	0x38, r24	; 56
		
		u32_a_overflowcounter++ ; /** INCREASE THE OVERFLOWS BY ONE **/
 510:	4f 5f       	subi	r20, 0xFF	; 255
 512:	5f 4f       	sbci	r21, 0xFF	; 255
 514:	6f 4f       	sbci	r22, 0xFF	; 255
 516:	7f 4f       	sbci	r23, 0xFF	; 255
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
	
	while ( u32_a_overflowcounter < u32_gs_tmr0nuofovs ) /** STUCK IN THIS LOOP UNTILL THIS CONDITION IS FALSE **/
 518:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 51c:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 520:	a0 91 62 00 	lds	r26, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
 524:	b0 91 63 00 	lds	r27, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 528:	48 17       	cp	r20, r24
 52a:	59 07       	cpc	r21, r25
 52c:	6a 07       	cpc	r22, r26
 52e:	7b 07       	cpc	r23, r27
 530:	48 f3       	brcs	.-46     	; 0x504 <TMR0_delaymicos+0x32>
		u32_a_overflowcounter++ ; /** INCREASE THE OVERFLOWS BY ONE **/
	}
	
	u32_a_overflowcounter = 0 ; /** REINTIALIZE THE OVERFLOWS COUNTER TO 0 AGAIN **/

	TMR0_stop(); /** STOP TMR0 TOSTART FROM 0 WHEN IT CALLED AGAIN **/
 532:	0e 94 5e 02 	call	0x4bc	; 0x4bc <TMR0_stop>
	
	return en_a_delaystatus ; 
 536:	80 e0       	ldi	r24, 0x00	; 0
 538:	08 95       	ret

0000053a <TIMER2_normalMode>:
/*Description: Set timer 2 control register to normal mode by clearing bits COM00 & COM01.  */
/*@param void                                                                               */	
/********************************************************************************************/
err_state TIMER2_normalMode(void)
{
    Clear_Bit(4,TCCR2);
 53a:	85 b5       	in	r24, 0x25	; 37
 53c:	8f 7e       	andi	r24, 0xEF	; 239
 53e:	85 bd       	out	0x25, r24	; 37
    Clear_Bit(5,TCCR2);
 540:	85 b5       	in	r24, 0x25	; 37
 542:	8f 7d       	andi	r24, 0xDF	; 223
 544:	85 bd       	out	0x25, r24	; 37
    return SUCCESS;
}
 546:	80 e0       	ldi	r24, 0x00	; 0
 548:	08 95       	ret

0000054a <_exit>:
 54a:	f8 94       	cli

0000054c <__stop_program>:
 54c:	ff cf       	rjmp	.-2      	; 0x54c <__stop_program>
